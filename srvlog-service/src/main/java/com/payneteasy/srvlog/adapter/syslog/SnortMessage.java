package com.payneteasy.srvlog.adapter.syslog;

import static com.payneteasy.srvlog.adapter.syslog.IpHeader.isSnortMessageContainsIpHeader;
import static com.payneteasy.srvlog.adapter.syslog.IpHeader.parseIpHeader;
import static com.payneteasy.srvlog.adapter.syslog.ProtocolHeader.parseTcpHeader;
import static com.payneteasy.srvlog.adapter.syslog.ProtocolHeader.parseUdpHeader;
import static com.payneteasy.srvlog.adapter.syslog.ProtocolRegistry.ICMP;
import static com.payneteasy.srvlog.adapter.syslog.ProtocolRegistry.TCP;
import static com.payneteasy.srvlog.adapter.syslog.ProtocolRegistry.UDP;
import static java.lang.Integer.parseInt;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.Scanner;
import static java.util.regex.Pattern.quote;

/**
 * Object representation for barnyard2 syslog_full output plugin message.
 *
 * @author imenem
 */
public class SnortMessage {

    /**
     * Returns true, if message generated by snort.
     *
     * @param       rawMessage      Message to check.
     *
     * @return      True, if message generated by snort.
     */
    public static boolean isMessageFromSnort(String rawMessage) {
        return rawMessage.contains("SNORTIDS[LOG]:");
    }

    /**
     * Parses message from barnyard2 syslog_full output plugin.
     *
     * @param       rawSnortMessage     Message from barnyard2.
     *
     * @return      Object representation of message.
     */
    public static SnortMessage parseSnortMessage(String rawSnortMessage) {
        SnortMessage snortMessage = new SnortMessage();

        if (!isMessageFromSnort(rawSnortMessage)) {
            throw new RuntimeException(
                "Message does not look like message from Snort. " +
                "Check message with method isMessageFromSnort() first."
            );
        }

        try (Scanner scanner = new Scanner(rawSnortMessage)) {
            scanner.useDelimiter(quote("||"));

            snortMessage.sensorName = scanner.findInLine("(?<=\\[SNORTIDS\\[LOG\\]: \\[).*?(?=\\] \\] \\|\\|)");
            snortMessage.setDate(scanner.findInLine("\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}.\\d{3}"));
            snortMessage.priority = parseInt(scanner.findInLine("\\d{1,2}"));
            snortMessage.classification = scanner.next().trim();
            snortMessage.alertCause = scanner.next().trim();

            if (isSnortMessageContainsIpHeader(rawSnortMessage)) {
                snortMessage.ipHeader = parseIpHeader(rawSnortMessage);
                // skip parsed ip header in scanner
                scanner.next();

                // snort message contains protocol header only for TCP, UDP and ICMP protocols
                switch (snortMessage.ipHeader.getProtocolNumber()) {
                    case TCP:
                        snortMessage.protocolHeader = parseTcpHeader(scanner.next());
                        break;
                    case UDP:
                        snortMessage.protocolHeader = parseUdpHeader(scanner.next());
                        break;
                    case ICMP:
                        // ICMP header does not contain valuable information, so skip it
                        scanner.next();
                        break;
                }
            }

            // skip payload length
            scanner.findInLine("[0-9]+");
            snortMessage.payload = decodePayload(scanner.findInLine("[0-9ABCDEF]+"));
        }

        return snortMessage;
    }

    /**
     * Converts payload from HEX format to ASCII.
     *
     * @param       payloadInHex        Payload in HEX formst.
     *
     * @return      Payload in ASCII format.
     */
    private static String decodePayload(String payloadInHex) {
        if (payloadInHex.length() % 2 != 0) {
            throw new RuntimeException("Wrong length: " + payloadInHex.length());
        }

        StringBuilder buffer = new StringBuilder(payloadInHex.length() / 2);

        for (int i = 0; i < (payloadInHex.length() - 1); i += 2) {
            buffer.append((char) parseInt(payloadInHex.substring(i, i + 2), 16));
        }

        return buffer.toString();
    }

    /**
     * Date and time formatter.
     *
     * {@link DateFormat} isn't thread safe, so we must create
     * own instance of {@link DateFormat} for each {@link SnortMessage} object.
     */
    private final DateFormat dateFormatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.S");

    /**
     * Name of software, that generates message.
     */
    private final String program = "snort";

    /**
     * Sensor name from barnyard2 syslog_full output plugin configuration.
     */
    private String sensorName;

    /**
     * Date and time, when message generated.
     */
    private Date date;

    /**
     * Message priority from snort rule.
     */
    private int priority;

    /**
     * Snort signature created for this message.
     * Classification contains generator id, rule id and rule version.
     */
    private String classification;

    /**
     * Message cause.
     */
    private String alertCause;

    /**
     * Packet ip header.
     */
    private IpHeader ipHeader;

    /**
     * Packet protocol header.
     */
    private ProtocolHeader protocolHeader;

    /**
     * Packet payload.
     */
    private String payload;

    /**
     * Returns date and time, when message generated.
     *
     * @return      Date and time, when message generated.
     */
    public Date getDate() {
        return (Date) date.clone();
    }

    /**
     * Returns message priority from snort rule.
     *
     * @return      Message priority from snort rule.
     */
    public int getPriority() {
        return priority;
    }

    /**
     * Returns sensor name from barnyard2 syslog_full output plugin configuration.
     *
     * @return      Sensor name from barnyard2 syslog_full output plugin configuration.
     */
    public String getSensorName() {
        return sensorName;
    }

    /**
     * Returns name of software, that generates message.
     *
     * @return      Name of software, that generates message.
     */
    public String getProgram() {
        return program;
    }

    @Override
    public String toString() {
        String stringRepresentation =
            "Date: " + dateFormatter.format(date) +
            "\nPriority: " + priority +
            "\nClassification: " + classification +
            "\nAlert cause: " + alertCause;

        if (ipHeader != null) {
            stringRepresentation += "\nIP header: " + ipHeader.toString();
        }

        if (protocolHeader != null) {
            stringRepresentation += "\nProtocol header: " + protocolHeader.toString();
        }

        stringRepresentation += "\nPayload" + payload;

        return stringRepresentation;
    }

    /**
     * Converts date from string to object and assigns it to object field.
     *
     * @param       date        Date and time, when message generated in string form.
     */
    private void setDate(String date) {
        try {
            this.date = dateFormatter.parse(date);
        }
        catch (ParseException ex) {
            throw new RuntimeException(ex);
        }
    }


}
